
       // (c) 2019 John Erps


       // Common App - Non-Work Days


       // Pass 0-10 parameters:

       //   1 I  (10)    : Mode.
       //                    *DISPLAY - Data records are displayed only and
       //                               can not be added, updated, deleted or
       //                               copied.
       //                    *EDIT    - Data records can be added, (in-line)
       //                               updated, deleted or copied.
       //                    *SELECT  - Data records are displayed only for
       //                               selection and can not be added,
       //                               updated, deleted or copied.

       //   2 I  (10)    : Special behavior codes.
       //                  This field can contain one or more letters listed
       //                  below to indicate special behaviors.
       //                    A - Keep the program active; do NOT end the
       //                        program on ENTER. Normally, the program is
       //                        ended when there are no pending actions or
       //                        subfile options to be processed. With this
       //                        special behavior the only way to end the
       //                        program is to press F3 or F12.
       //                    I - Inhibit in-line updating of data records
       //                        (ignored when not in *EDIT mode).
       //                    J - Do not allow adding or copying data records
       //                        (ignored when not in *EDIT mode).
       //                    K - Do not allow deleting data records
       //                        (ignored when not in *EDIT mode).
       //                    V - Force DSPMOD(*NORMAL) on program init.
       //                    W - Force DSPMOD(*WIDE) on program init.
       //                    X - Do not allow resize/refresh (F9).

       //   3 O  (2,0)   : Return code (ERROR if >=30)
       //                    00 - Program ended normally (with ENTER).
       //                    01 - F3 key was pressed (exit).
       //                    02 - F12 key was pressed (cancel).
       //                    10 - Data record has been selected (mode *SELECT).
       //                         Output parms contain the key of the selected
       //                         data record.
       //                    30 - An unspecified error occurred.
       //                    31 - Illegal parameter value.
       //                    32 - Function not allowed.
       //                    33 - Program fault.

       //   4 O  (100)   : Return message 1 (error).
       //   5 O  (100)   : Return message 2 (cause).

       //                  If mode is *SELECT then return the selected
       //                  year, month, day of month, week and day of
       //                  week (returncode 10), or all zero if nothing
       //                  was selected.
       //   6 O  (4,0)   : Year.
       //   7 O  (2,0)   : Month.
       //   8 O  (2,0)   : Day of month.
       //   9 O  (2,0)   : Week.
       //  10 O  (1,0)   : Day of week.


       //$B OVRDBF FILE(SFRFILE1) TOFILE(CSYSBASEF2) OVRSCOPE(*JOB)
       //$A DLTOVR FILE(SFRFILE1) LVL(*JOB)


       // Binding directories.
       // Release all service programs at the end of main by calling the
       // "RlsSp*" procedure for each. Be sure to do this in the correct
       // order, i.e. highest level first and lowest level last.
     h bnddir(
     h             'CAPPDISP'
     h            :'CAPPBASE'
     h            :'CSYSBASE'
     h       )

      /include QINCSRC,DPGM_HEAD


     fCAFNWD    cf   e             workstn infds(WSI)
     f                                     sfile(DFSFR1:SFLR1#)

     fCSYSBASEF2uf a e           k disk

       // The following files (SFRFILEn) are ONLY used to read data to
       // populate subfile n. File pointers must be retained for these
       // files to correctly read the next page. Therefore, ensure that
       // the ODP's for these files are NOT shared.
     fSFRFILE1  if   e           k disk    rename(NWDREC:SFRFILE1R)
     f                                     extfile('*LIBL/CSYSBASEF2')


       // ----- Includes

      /include QINCSRC,CAFNWD

      /include CAPPDISPS,INCL_API
      /include CAPPBASES,INCL_API
      /include CSYSBASES,INCL_API


       // ----- Constants

       // The minimum number of parameters needed by this program.
     d MinPgmParms     c                   0

       // Number of lines in a page in subfile 1 in *NORMAL mode.
     d SflPagelen1     c                   13
       // Row with the top line of a page in subfile 1.
     d SflTopline1     c                   8

       // Row on which to display the bottom message (*NORMAL and *WIDE).
     d MsgRowNormal    c                   22
     d MsgRowWide      c                   25


       // ----- External Data Structures


       // ----- Internal Data Structures

      /include QINCSRC,DS_PSI

       // Error structure.
       // For convenience, use local procedures "L_SetErr" and "L_AddErrFld".
     d Err             ds                  qualified inz
         // *on if an error occurred, else *off.
     d   e                             n
         // names of fields/attributes in error.
     d   flds                        12    dim(40)

       // Positioning keys.
       //   1: NWDYEAR (SFRFILE1)
     d Poskey1         ds                  qualified inz
     d   f1                                like(D__POS1F1)
     d   f1a                               like(D__POS1F1A)

       // Data record key.
     d DrKey           ds                  qualified inz
     d   f1                                like(NWDYEAR)
     d   f2                                like(NWDMONTH)
     d   f3                                like(NWDDAY)
     d   f4                                like(NWDWEEK)
     d   f5                                like(NWDDNUM)


       // ----- Arrays

       // Array "FEMap" associates field/attribute names with error indicators
       // *in31-*in69. A question mark ("?") in a name means that the position
       // matches any character. The first name which matches a field/attribute
       // name (case sensitive) determines the indicator to be set to *on.
       // Execute subr. "SetErrFldsInd" to set error indicators according to
       // the names in array "Err.flds" (see above).
     d FEMap           s             14    ctdata dim(50)
       // Cursor locations.
     d CursLocs        s              7    ctdata dim(50)
       // Texts
     d Text            s             80    ctdata dim(50)
       // Function key texts
     d FunText         s             60    ctdata dim(50)
       // Subfile option texts
     d SfoText         s             60    ctdata dim(50)


       // ----- Fields/Vars

       // Number of parameters passed to this program.
     d Parms#          s             10i 0

       // Program activated.
     d PgmActivated    s               n   inz(*off)

       // Return code/message1/2 to be returned to caller.
     d Rtncd           s              2  0
     d Rtnmsg1         s            100
     d Rtnmsg2         s            100

       // Modes:
     d ModeDisplay     s               n
     d ModeEdit        s               n
     d ModeSelect      s               n

       // Special behaviors:
       // - SbKeepActive : Keep program active.
       // - SbNoInlUpd   : Do not allow in-line updating in *EDIT mode.
       // - SbNoAdd      : Do not allow add or copy in *EDIT mode.
       // - SbNoDel      : Do not allow delete in *EDIT mode.
       // - SbDspiNorm   : Force DSPMOD(*NORMAL) on program init.
       // - SbDspiWide   : Force DSPMOD(*WIDE) on program init.
       // - SbNoResize   : Do not allow resize/refresh (F9).
     d SbKeepActive    s               n
     d SbNoInlUpd      s               n
     d SbNoAdd         s               n
     d SbNoDel         s               n
     d SbDspiNorm      s               n
     d SbDspiWide      s               n
     d SbNoResize      s               n

       // Display mode *WIDE if *on.
     d DspWide         s               n
       // Current screen rows and columns.
     d ScreenRows      s             10i 0
     d ScreenCols      s             10i 0
       // The screen to be displayed/processed (0 = exit).
     d Screen          s             10i 0
       // Previous screen.
     d PrevScreen      s                   like(Screen)
       // The current positioning key to be used (Poskey*).
     d CurPoskey       s             10i 0
       // The new positioning key which is set in subr. "CheckPositioning".
     d NewPoskey       s             10i 0
       // Is set to *on if a new positioning has been effectuated.
     d Positioned      s               n
       // If set to *on then the values of the screen positioning fields
       // (D__POS*) are retained on next screen output.
     d RetainPosFlds   s               n
       // Is set to *on in subr. "ValSubfile" if subr. "PcsSubfile" needs
       // to be executed.
     d SflPcs          s               n
       // Is *on if subfile n is empty.
     d SflEmpty1       s               n
       // Is set to *on in subr. "ReadFirstPage" or "ReadNextPage" if
       // end-of-data has been reached for subfile n.
     d EOD1            s               n
       // Recno for subfile n.
     d SFLR1#          s              5  0
       // Recno total for subfile n.
     d SFLR1#T         s              5  0

       // The primary (error)message, to be displayed at the bottom, in
       // "ExScreen". This field is always cleared automatically, after
       // "ExScreen", with "CAPPBASE/ClrDspMsgs" (see below).
       // For convenience, use local procedures "L_SetErr" and "L_AddErrFld"
       // to set the "Err" data structure and "DspMsg" in one go in case
       // of an error.
       // NOTE: This field is defined in and exported from *SRVPGM CAPPBASE.
     d DspMsg          s            130            import('DspMsg')

       // A list of max. 99 supplementary (error)messages, to be displayed
       // in "ExScreen", like "DspMsg". This array is also always cleared
       // automatically, after "ExScreen". Field "DspMsg", together with
       // "DspMsgList" can be considered as one list with max. 100 messages,
       // where "DspMsg" is the first one, and "DspMsgList(1)" the second.
       // The first message in this list (either "DspMsg" or "DspMsgList(1)")
       // is displayed at the bottom, in "ExScreen". The last message in
       // "DspMsgList" is by definition in the element just before the first
       // blank element. Thus, if "DspMsgList(1)" is blank then the array is
       // considered to contain no messages at all. If "DspMsgList(1)" and
       // "DspMsg" are both not blank, or "DspMsgList(1)" and "DspMsgList(2)"
       // are both not blank, a "+" at the right of the displayed message at
       // the bottom is shown to indicate more messages. The user may press
       // F22 to display all messages within a pageable window, which includes
       // "DspMsg" (displayed at the top).
       // NOTES:
       //   - Use "CAPPBASE/ClrDspMsgs" to clear all messages, including
       //     "DspMsg".
       //   - Use "CAPPBASE/AddToDspMsgList" to place a message into the
       //     first non-blank element of "DspMsgList".
       //   - Array "DspMsgList" is defined in and exported from *SRVPGM
       //     CAPPBASE.
     d DspMsgList      s            130    dim(99) import('DspMsgList')

       // Is set to *on in "ExScreen" if there are more messages to display,
       // i.e. a "+" is shown on the right of the displayed message at the
       // bottom.
     d MoreMsgs        s               n

       // The statusmessage to be displayed at the bottom row, in "ExScreen",
       // but only if "StatMsg <> *BLANKS", and "StatMsg <> DspMsg" and
       // "StatMsg <> DspMsgList(1)". This field is NOT cleared automatically.
       // NOTE: the statusmessage replaces the second line with function
       // key information, which is normally displayed at the bottom row.
     d StatMsg         s            130

       // The row on the screen on which to display the bottom message,
       // determined in subr. "CalcScrSizes".
     d DspMsgRow       s             10i 0

       // Cursor location on last display input operation (exfmt).
     d CursRow         s             10i 0
     d CursCol         s             10i 0

       // If *on, set cursor on location "CursRow"/"CursCol" on next
       // display output operation (exfmt).
     d SetCurs         s               n
       // Press key again to confirm if *off.
     d ConfirmExit     s               n
     d ConfirmRefresh  s               n
     d ConfirmResize   s               n
       // Header displayed on screen.
     d HdrText         s            100
       // Subfile options or function keys to be displayed on screen.
     d DspOpts         s           1056
       // Current subfile page length (number of rows).
     d PgLen           s             10i 0
       // Screen row of the first record of the current subfile page.
     d PgTopl          s             10i 0
       // A message.
     d Msg             s            130
       // A message number.
     d Msg#            s             10i 0
       // Subfile record#
     d SflRec          s             10i 0

       // Standard program parameter fields.
     d Pmode           s             10
     d Pspcbhvr        s             10
     d Prc             s                   like(Rtncd)
     d Prm1            s                   like(Rtnmsg1)
     d Prm2            s                   like(Rtnmsg2)

       // Original input parameter values.
     d Imode           s             10
     d Ispcbhvr        s             10

       // Database Query & Fetch fields.
     d DbqId           s             20
     d DbqStmt         s          30000    varying
       // Cursor id.
     d DbqCursId       s              5i 0 inz(-1)

       // "DbqError" is set to *on if the query that was last executed in
       // subr. "SFn_QUERY" resulted in an error; no records to fetch.
     d DbqError        s               n

       // "DbqFetchOK" is set to *on in subr. "SFn_FETCH" if a row has been
       // fetched, else it is set to *on.
     d DbqFetchOK      s               n

       // "DbqFetched" is set to *off when the query has has been executed
       // in subr. "SFn_QUERY" and is set to *on when a row has been fetched
       // with subr. "SFn_FETCH".
     d DbqFetched      s               n

       // If "DbqResetCursor" is set to *on, subr. "SFn_QUERY" does not
       // execute the query and the current result set is kept, and next
       // time subr. "SFn_FETCH" is executed the cursor is positioned on
       // the first row. "DbqResetCursor"" is always set to *off again
       // in subr. "SFn_FETCH".
     d DbqResetCursor  s               n

       // If "DbqSkipFetch" is set to *on, next time subr. "SFn_FETCH" is
       // executed the fetch is not executed and the current row is kept,
       // and the cursor is not moved. "DbqSkipFetch" is always set to *off
       // again in subr. "SFn_FETCH".
     d DbqSkipFetch    s               n

       // Level break indicators (array "DbqlInd") and associated level-break
       // fields, which are initialized in "SFn_QUERY" and updated in subr.
       // "SFn_FETCH". The fields contain values of the previous row, which
       // are compared with the values of the current row in subr. "SFn_FETCH".
       // Array "DbqlNull" is set in subr. "SFn_FETCH" to indicate whether the
       // associated level-break field was NULL in the previous row.
     d DbqlInd         s               n   dim(99)
     d DbqlNull        s               n   dim(99)
     d DbqlNWDYEAR     s                   like(NWDYEAR)


       // ----- MAIN Prototype

     d MAIN            pr


       // ----- Local Prototypes

      /include QINCSRC,DPGM_LPP


       // ----- Program Entry

     d PgmCAFNWD       pi
     d   @@Mode                      10    const options(*nopass)
     d   @@Spcbhvr                   10    const options(*nopass)
     d   @@Rtncd                      2  0       options(*nopass)
     d   @@Rtnmsg1                  100          options(*nopass)
     d   @@Rtnmsg2                  100          options(*nopass)
     d   @@SelYear                    4  0       options(*nopass)
     d   @@SelMonth                   2  0       options(*nopass)
     d   @@SelDay                     2  0       options(*nopass)
     d   @@SelWeek                    2  0       options(*nopass)
     d   @@SelDNum                    1  0       options(*nopass)

      /free


       *inLR = *on;

       Parms# = %parms;

       if Parms# > 2;
         @@Rtncd = 0;
       endif;
       if Parms# > 3;
         @@Rtnmsg1 = '';
       endif;
       if Parms# > 4;
         @@Rtnmsg2 = '';
       endif;
       if Parms# > 5;
         @@SelYear = 0;
       endif;
       if Parms# > 6;
         @@SelMonth = 0;
       endif;
       if Parms# > 7;
         @@SelDay = 0;
       endif;
       if Parms# > 8;
         @@SelWeek = 0;
       endif;
       if Parms# > 9;
         @@SelDNum = 0;
       endif;

       Rtncd = 0;
       Rtnmsg1 = '';
       Rtnmsg2 = '';

       MAIN();

       if     ModeSelect
          and Rtncd = 10;
         // Set output parameters to selected key.
         if Parms# > 5;
           @@SelYear = DrKey.f1;
         endif;
         if Parms# > 6;
           @@SelMonth = DrKey.f2;
         endif;
         if Parms# > 7;
           @@SelDay = DrKey.f3;
         endif;
         if Parms# > 8;
           @@SelWeek = DrKey.f4;
         endif;
         if Parms# > 9;
           @@SelDNum = DrKey.f5;
         endif;
       endif;

       // Release all resources.
       RlsSpCAPPDISP();
       RlsSpCAPPBASE();
       RlsSpCSYSBASE();

       if Parms# > 2;
         @@Rtncd = Rtncd;
       endif;
       if Parms# > 3;
         @@Rtnmsg1 = Rtnmsg1;
       endif;
       if Parms# > 4;
         @@Rtnmsg2 = Rtnmsg2;
       endif;

       return;


      /end-free


     p MAIN            b
     d MAIN            pi

     d flag            s               n
     d sflopt          s                   like(D_SFLOPT)
     d exit            s               n
     d cancel          s               n
     d newcurrec       s                   like(D__CURREC)
     d sflrecs         s                   like(SFLR1#T)
     d numValue        s             30  9
     d add#            s             10i 0
     d upd#            s             10i 0
     d del#            s             10i 0
     d cpy#            s             10i 0
     d sfD_YEARA       s                   like(D_YEARA)
     d sfD_MONTHA      s                   like(D_MONTHA)
     d sfD_DAYA        s                   like(D_DAYA)
     d sfD_WEEKA       s                   like(D_WEEKA)
     d sfD_DNUMA       s                   like(D_DNUMA)
     d sfD_TYPE        s                   like(D_TYPE)
     d sfD_TNAME       s                   like(D_TNAME)
     d x               s             10i 0
     d dt              s               d
     d wk              s             10i 0
     d dn              s             10i 0
     d t               s            100    varying

      /free


       dou 0=0;

       if not PgmActivated;
         PgmActivated = *on;
         exsr Activate;
         if Rtncd <> 0;
           leave;
         endif;
       endif;

       exsr Init;
       if Rtncd <> 0;
         leave;
       endif;

       dow Screen <> 0;

         // Check if display mode *WIDE is supported.
         if     DspWide
            and not IsDspModeWideSupported();
           DspWide = *off;
           PushDspMsgs(RtvAMsgAB(1046:CAmsWarning));
         endif;

         // Make sure the first message is in "DspMsg" and up.
         DropDspMsgs();

         // Calculate current screen sizes.
         exsr CalcScrSizes;

         // Execute screen / subfile.
         exsr ExScreen;

         clear Err;       // Clear error data.
         ClrDspMsgs();    // Clear (error)messages.
         MoreMsgs = *off; // No more messages.

         NewPoskey = 0;
         Positioned = *off;

         if not KeyPressed(KsF03);
           ConfirmExit = *off;
         endif;
         if not KeyPressed(KsF05);
           ConfirmRefresh = *off;
         endif;
         if not KeyPressed(KsF09);
           ConfirmResize = *off;
         endif;

         PrevScreen = Screen;

         if KeyPressed(KsPageDown);
           // Pagedown pressed; read next subfile page.
           if     Screen = 1
              and not SflEmpty1
              and EOD1;
             DspMsg = RtvAMsgAB(1001);
           elseif    Screen = 1
                 and SflEmpty1;
             DspMsg = RtvAMsgAB(1002);
           else;
             exsr ReadNextPage;
           endif;
         elseif KeyPressed(KsPageUp);
           // Pageup pressed; display message.
           if     Screen = 1
              and SflEmpty1;
             DspMsg = RtvAMsgAB(1002);
           else;
             DspMsg = RtvAMsgAB(1005);
           endif;
           SetCurs = *on; // retain cursor location.
         elseif KeyPressed(KsF03);
           // F03 pressed; exit program (if confirmed).
           if ConfirmExit;
             ConfirmExit = *off;
             Rtncd = 1;
             Screen = 0;
           else;
             ConfirmExit = *on;
             DspMsg = RtvAMsgAB(1004:CAmsInfo:'F3');
           endif;
         elseif KeyPressed(KsF04);
           // F04 pressed; select item.
           exsr SelectItem;
           SetCurs = *on; // retain cursor location.
         elseif KeyPressed(KsF05);
           // F05 pressed; read first page (if confirmed).
           if    ConfirmRefresh
              or not ModeEdit;
             ConfirmRefresh = *off;
             exsr ReadFirstPage;
           else;
             ConfirmRefresh = *on;
             DspMsg = RtvAMsgAB(1071);
           endif;
         elseif    KeyPressed(KsF06)
               and ModeEdit
               and not SbNoAdd;
           // F06 pressed; add data record.
           exsr AddNewRecord;
           SetCurs = *off; // Do not retain cursor location.
         elseif     KeyPressed(KsF09)
                and not SbNoResize;
           // F09 pressed; switch screen size & refresh (if confirmed).
           if    ConfirmResize
              or not ModeEdit;
             ConfirmResize = *off;
             DspWide = not DspWide;
             exsr ReadFirstPage;
           else;
             ConfirmResize = *on;
             DspMsg = RtvAMsgAB(1072);
           endif;
         elseif KeyPressed(KsF12);
           // F12 pressed; cancel program.
           Rtncd = 2;
           Screen = 0;
         elseif    KeyPressed(KsF17)
                or KeyPressed(KsF18);
           // F17/F18 pressed; go to first/last page.
           D__CURREC = 1;
           if     KeyPressed(KsF18)
              and SFLR1#T > PgLen;
             D__CURREC = SFLR1#T - Pglen + 1;
           endif;
         elseif KeyPressed(KsEnter);
           // Enter pressed.
           exsr CheckPositioning;
           if not Err.e;
             // No errors; validate screen.
             exsr ValScreen;
             if not Err.e;
               // No errors; process screen.
               exsr PcsScreen;
             endif;
           endif;
           if not Err.e;
             // No errors; validate subfile.
             exsr ValSubfile;
             if     NewPoskey > 0
                and not Err.e
                and SflPcs;
               // Can not reposition with other actions pending.
               L_SetErr(RtvAMsgAB(1007:CAmsFatal));
             endif;
             if not Err.e;
               // No errors.
               if SflPcs;
                 // Process subfile.
                 exsr PcsSubfile;
               elseif DspMsg = '';
                 // Nothing to do.
                 DspMsg = RtvAMsgAB(1202);
               endif;
             endif;
             if     not Err.e
                and not SflPcs
                and NewPoskey > 0;
               // No errors, no sfl processing and new pos.; read first page.
               exsr SetPoskey;
               exsr ReadFirstPage;
               Positioned = *on;
               DspMsg = RtvAMsgAB(1211);
             endif;
             if     not SbKeepActive
                and not Err.e
                and not SflPcs
                and NewPoskey = 0;
               // No pending actions and no sfl processing; end program.
               Screen = 0;
             endif;
           endif;
         else;
           // Function key not supported.
           L_SetErr(RtvAMsgAB(1010:CAmsFatal));
         endif;

       enddo;

       enddo;

       return;


       // Subfile 1: Query
       // Set "Err.e" to *on in case of an error.
       begsr SF1_QUERY;

         // No rows fetched yet.
         DbqFetched = *off;

         EOD1 = *off;
         DbqSkipFetch   = *off;

         // Initialize all level-break indicators with *on and all
         // level-break fields with *loval. The fields contain the
         // values of the previously fetched row. The indicators
         // and fields are initialized here and updated in SF1_FETCH.
         // Used level-break indicators and associated fields:
         //    1 : NWDYEAR
         DbqlInd(*)     = *on;
         DbqlNull(*)    = *on;
         DbqlNWDYEAR    = *loval;

         // Clear all data fields.
         clear SFRFILE1R;

         if not DbqResetCursor;

         DbqError = *on;

         // Execute the query.
         setll(e) (Poskey1.f1) SFRFILE1;
         if %error;
           L_SetErr(RtvAMsgAB(1121:CAmsFatal));
         else;
           DbqError = *off;
         endif;

         //DbqId   = '*PGM-' + PSI.pgmname;
         //DbqStmt = SqliRtvStoredSql(DbqId);

         endif;

         if     Err.e
            and DspMsg <> '';
           StatMsg = DspMsg;
         endif;

         if DbqError;
           EOD1 = *on;
         endif;

       endsr;


       // Subfile 1: Fetch
       // Set "Err.e" to *on in case of an error.
       begsr SF1_FETCH;

         DbqFetchOK = *off;

         dou 0=0;

         if    DbqError
            or EOD1;
           leave;
         endif;

         if DbqFetched;
           // A row has been fetched previously. Store the current
           // non-null column values in level-break fields "Dbql*",
           // and set the corresponding elements in array "DbqlNull"
           // to *on if the associated current column value is null.
           DbqlNull(*) = *off;
           DbqlNWDYEAR = NWDYEAR;
         endif;

         if DbqSkipFetch;
           leave;
         endif;

         if DbqResetCursor;
           // NOT SUPPORTED!
           flag = *off;
         else;
           read(e) SFRFILE1;
           flag = not %error;
         endif;
         if flag;
           StatMsg = '';
           if %eof;
             // End of data reached.
             EOD1 = *on;
           else;
             // A row has been fetched.
             DbqFetchOK = *on;
             DbqFetched = *on;
           endif;
         else;
           // Error...
           L_SetErr(RtvAMsgAB(1122:CAmsFatal));
           // Clear all data fields.
           clear SFRFILE1R;
         endif;

         if     Err.e
            and DspMsg <> ''
            and StatMsg = '';
           StatMsg = DspMsg;
         endif;

         enddo;

         if EOD1;
           // Set all level-break indicators to *on.
           DbqlInd(*) = *on;
         elseif DbqFetched;

           // Set level-break indicators for the current row, by comparing
           // the current and previous values of the level-break fields. A
           // level-break is always triggered if the current or the previous
           // value of a level-break field is null ("DbqlNull").

           // Set all to *off first.
           DbqlInd(*) = *off;

           if NWDYEAR <> DbqlNWDYEAR;
             DbqlInd(1) = *on;
           endif;

         endif;

         DbqResetCursor = *off;
         DbqSkipFetch = *off;

       endsr;


       // Perform actions when the program is first activated.
       begsr Activate;

         // Set WSI@ to let service program CSYSBASE access
         // the workstation information in ds WSI.
         WSI@ = %addr(WSI);

       endsr;


       // Initialize program.
       begsr Init;

         clear Err;

         ClrDspMsgs();
         MoreMsgs = *off;
         StatMsg = '';

         Screen = 1;
         SflEmpty1 = *on;
         EOD1 = *off;

         ConfirmExit = *off;

         CursRow = 1;
         CursCol = 1;
         SetCurs = *off;

         CurPoskey = 1;
         clear Poskey1;
         Poskey1.f1 = %subdt(%date:*y);
         evalr Poskey1.f1a = %char(Poskey1.f1);
         RetainPosFlds = *off;

         DbqId          = '';
         DbqStmt        = '';
         DbqCursId      = -1;
         DbqError       = *off;
         DbqFetchOK     = *off;
         DbqFetched     = *off;
         DbqResetCursor = *off;
         DbqSkipFetch   = *off;

         Imode = '';
         Ispcbhvr = '';

         // Check number of parameters.
         if Parms# < MinPgmParms;
           Rtncd = 31;
           Rtnmsg1 =   'This program needs at least '
                     + %char(MinPgmParms) + ' parameters.';
           leavesr;
         endif;

         // Set mode indicators.
         if Parms# > 0;
           Imode = @@Mode;
         else;
           Imode = '*DISPLAY';
         endif;
         ModeDisplay = Imode = '*DISPLAY';
         ModeEdit    = Imode = '*EDIT';
         ModeSelect  = Imode = '*SELECT';
         if     not ModeDisplay
            and not ModeEdit
            and not ModeSelect;
           Rtncd = 31;
           Rtnmsg1 = 'Value of parameter 1 (mode) is unsupported.';
           leavesr;
         endif;

         // Set special behavior indicators.
         if Parms# > 1;
           Ispcbhvr = @@Spcbhvr;
         endif;
         SbKeepActive = %scan('A':Ispcbhvr) > 0;
         SbNoInlUpd   = %scan('I':Ispcbhvr) > 0;
         SbNoAdd      = %scan('J':Ispcbhvr) > 0;
         SbNoDel      = %scan('K':Ispcbhvr) > 0;
         SbDspiNorm   = %scan('V':Ispcbhvr) > 0;
         SbDspiWide   = %scan('W':Ispcbhvr) > 0;
         SbNoResize   = %scan('X':Ispcbhvr) > 0;

         if SbDspiNorm;
           DspWide = *off;
         elseif SbDspiWide;
           DspWide = *on;
         else;
           DspWide = IsDspModeWide();
         endif;

         D__CURREC = 1;

         exsr ReadFirstPage;

       endsr;


       // Calculate current screen sizes.
       begsr CalcScrSizes;

         select;
         // when Screen = 1;
         other;
           // Screen 1 is default.
           PgLen = SflPagelen1;
           PgTopl = SflTopline1;
         endsl;
         if DspWide;
           ScreenRows = 27;
           ScreenCols = 132;
           PgLen = PgLen + 3;
           DspMsgRow = MsgRowWide;
         else;
           ScreenRows = 24;
           ScreenCols = 80;
           DspMsgRow = MsgRowNormal;
         endif;

       endsr;


       // Execute the current screen ("Screen").
       begsr ExScreen;

         if Err.e;
           // Set error indicators (31-69); see "FEMap".
           exsr SetErrFldsInd;
         endif;

         // Set generic display indicators.
         *in10 = DspWide;
         *in21 = *on;
         *in22 = *on;
         *in23 = *off;
         *in30 = Err.e;

         // "Msg" contains the message to display at the bottom.
         Msg = '';
         if DspMsg <> '';
           Msg = DspMsg;
           Msg# = 0;
         else;
           Msg = DspMsgList(1);
           Msg# = 1;
         endif;

         if        DspMsg <> ''
               and DspMsgList(1) <> ''
            or     DspMsgList(1) <> ''
               and DspMsgList(2) <> '';
           // Show "+" to indicate more messages.
           MoreMsgs = *on;
         endif;

         if Msg = '';
           // Set informational message.
           select;
           when Screen = 1 and SflEmpty1;
             // Empty subfile.
             Msg = RtvAMsgAB(1009);
           when     NewPoskey > 0
                and not Positioned;
             Msg = RtvAMsgAB(1008);
           when D__CURREC <= PgLen;
             Msg = RtvAMsgAB(1011);
           endsl;
         endif;

         // Header.
         select;
         when ModeDisplay;
           HdrText = Text(3);
         when ModeSelect;
           HdrText = Text(4);
         other;
           HdrText = Text(2);
         endsl;
         D__HDPGMI = %trim(PSI.pgmname) + '.' + %char(Screen);
         D__HDDATE = PtDate(%date);
         D__HDTIME = PtTime(%time);
         D__HDUSRI = PSI.curuser;
         if PSI.jobuser <> PSI.curuser;
           D__HDUSRI = %trim(D__HDUSRI) + '/' + %trim(PSI.jobuser);
         endif;
         evalr D__HDJOBI = %trim(PSI.jobname) + '/' +
                           %editc(PSI.jobnumber:'X');
         D__HDTXT1 = '';
         D__HDTXT2 = '';
         %subst(D__HDTXT1:
             %div(%len(D__HDTXT1)-%len(%trim(Text(1))):2)+1)
             = %trim(Text(1));
         %subst(D__HDTXT2:
             %div(%len(D__HDTXT2)-%len(%trim(HdrText)):2)-1)
             = '  ' + %trim(HdrText);
         write DFHEADER;

         // Footer.
         DspOpts = '';
         AddToAppOpts(FunText( 1):DspOpts:DspWide);
         if     ModeEdit
            and not SbNoAdd;
           AddToAppOpts(FunText( 6):DspOpts:DspWide);
         endif;
         D__FTTEXT  = DspOpts;
         D__FTTEXTW = DspOpts;

         // Subfile options.
         DspOpts = '';
         if ModeSelect;
           AddToAppOpts(SfoText(1):DspOpts:DspWide);
         endif;
         if ModeEdit;
           //AddToAppOpts(SfoText(2):DspOpts:DspWide);
           if not SbNoAdd;
             AddToAppOpts(SfoText(3):DspOpts:DspWide);
           endif;
         endif;
         if     ModeEdit
            and not SbNoDel;
           AddToAppOpts(SfoText(4):DspOpts:DspWide);
         endif;
         //AddToAppOpts(SfoText(5):DspOpts:DspWide);
         D__SFOPTS  = DspOpts;
         D__SFOPTSW = DspOpts;

         if D__CURREC < 1;
           D__CURREC = 1;
         endif;
         if D__CURREC > SFLR1#T;
           D__CURREC = SFLR1#T;
         endif;

         dou not (   KeyPressed(KsF01)
                  or KeyPressed(KsF10)
                  or KeyPressed(KsF22)
                  or     (   KeyPressed(KsPageDown)
                          or KeyPressed(KsPageUp))
                     and GetCursRow() = DspMsgRow);

           D__FTMSG1  = Msg;
           D__FTMSG1W = Msg;
           D__FTMSG2  = Msg;
           D__FTMSG2W = Msg;
           if MoreMsgs;
             if Msg# < GetDspMsgListCount();
               %subst(D__FTMSG1 :%len(D__FTMSG1 )-1) = ' +';
               %subst(D__FTMSG1W:%len(D__FTMSG1W)-1) = ' +';
               %subst(D__FTMSG2 :%len(D__FTMSG2 )-1) = ' +';
               %subst(D__FTMSG2W:%len(D__FTMSG2W)-1) = ' +';
             else;
               %subst(D__FTMSG1 :%len(D__FTMSG1 )-1) = ' <';
               %subst(D__FTMSG1W:%len(D__FTMSG1W)-1) = ' <';
               %subst(D__FTMSG2 :%len(D__FTMSG2 )-1) = ' <';
               %subst(D__FTMSG2W:%len(D__FTMSG2W)-1) = ' <';
             endif;
           endif;
           if DspWide;
             write DFFOOTERW;
           else;
             write DFFOOTER;
           endif;

           if     StatMsg <> ''
              and StatMsg <> Msg;
             // Display statusmessage.
             DspStatMsg(%trimr(StatMsg));
           endif;

           *in27 = SetCurs;
           if SetCurs;
             if     CursRow >= 1
                and CursRow <= ScreenRows
                and CursCol >= 1
                and CursCol <= ScreenCols;
               D__CURSROW = CursRow;
               D__CURSCOL = CursCol;
             else;
               *in27 = *off;
             endif;
             SetCurs = *off;
           endif;

           if not RetainPosFlds;
             // Set screen positioning fields.
             exsr SetPosFields;
           endif;

           select;
           // when Screen = ?;
           other;
             // Screen 1 is default.
             if SflEmpty1;
               *in22 = *off;
               if DspWide;
                 write DFSFND1W;
               else;
                 write DFSFND1;
               endif;
             endif;
             *in29 = EOD1;
             exfmt DFSFC1;
           endsl;

           // Determine cursor location.
           CursRow = GetCursRow();
           CursCol = GetCursCol();

           if KeyPressed(KsF10);
             exsr SetNextCursLoc;
           elseif    KeyPressed(KsF01)
                  or KeyPressed(KsF22);
             SetCurs = *on;
             if KeyPressed(KsF01);
               DspHelp(' ');
             elseif MoreMsgs;
               ShowDspMsgs();
             endif;
           elseif     (   KeyPressed(KsPageDown)
                       or KeyPressed(KsPageUp))
                  and GetCursRow() = DspMsgRow;
             SetCurs = *on;
             if MoreMsgs;
               if KeyPressed(KsPageDown);
                 Msg# = Msg# + 1;
               else;
                 Msg# = Msg# - 1;
               endif;
               if Msg# < 0;
                 Msg# = GetDspMsgListCount();
               elseif Msg# > GetDspMsgListCount();
                 Msg# = 0;
               endif;
               if Msg# = 0;
                 Msg = DspMsg;
               else;
                 Msg = DspMsgList(Msg#);
               endif;
               Msg = %char(Msg# + 1) + ': ' + Msg;
             endif;
           endif;

         enddo;

         // Set off all indicators.
         *in(*) = *off;

         // Calculate the correct subfile record# to set the
         // cursor location on next display.
         if CursRow < PgTopl;
           D__CURREC = WSI.sfrrn;
         elseif CursRow >= PgTopl + PgLen;
           D__CURREC = WSI.sfrrn + PgLen - 1;
         else;
           D__CURREC = WSI.sfrrn + CursRow - PgTopl;
         endif;
         if D__CURREC < 1;
           D__CURREC = 1;
         endif;
         if D__CURREC > SFLR1#T;
           D__CURREC = SFLR1#T;
         endif;

         if     not KeyPressed(KsPageDown)
            and not KeyPressed(KsPageUp);
           // Clear/reset all subfile indicators, flags, etc.
           for SflRec = 1 to SFLR1#T;
             select;
             // when Screen = 1;
             other;
               // Screen 1 is default.
               chain SflRec DFSFR1;
               exsr ClrIndDFSFR1;
               D_AUIND = ''; // add/update indicator
               D__PCS = '';
               exsr SetIndDFSFR1;
               update DFSFR1;
             endsl;
           endfor;
         endif;

         SetCurs = *off;
         RetainPosFlds = *off;

       endsr;


       // Validate the current screen, identified with "Screen".
       begsr ValScreen;
       endsr;


       // Process the current screen, identified with "Screen".
       begsr PcsScreen;
       endsr;


       // Select an item for the current display field on the
       // current screen, identified with "Screen".
       begsr SelectItem;

         if not ModeEdit;
           L_SetErr(RtvAMsgAB(1025:CAmsFatal));
           leavesr;
         endif;

         select;
         // when Screen = ?;
         other;
           // Screen 1 is default.
           select;
           when D__CURSFLD = 'D__POSXFX';
             //if SelXxx(SelXxx$:-1);
             //  D__POSXFX = SelXxx$.f1;
             //  RetainPosFlds = *on;
             //  DspMsg = RtvAMsgAB(1016);
             //else;
             //  DspMsg = RtvAMsgAB(1059);
             //endif;
             //leavesr;
           when     D__CURSFLD = 'D_TYPE'
                and D__CURREC > 0
                and D__CURREC <= SFLR1#T;
             chain D__CURREC DFSFR1;
             if %found;
               if SelNwdType(SelNwdType$:-1);
                 exsr ClrIndDFSFR1;
                 D_TYPE = SelNwdType$.f1;
                 D_TNAME = GetNwdtName(D_TYPE);
                 if D_TNAME = '';
                   D_TNAME = '?';
                 endif;
                 exsr SetIndDFSFR1;
                 update DFSFR1;
                 DspMsg = RtvAMsgAB(1016);
               else;
                 DspMsg = RtvAMsgAB(1059);
               endif;
               leavesr;
             endif;
           endsl;
         endsl;

         L_SetErr(RtvAMsgAB(1015:CAmsFatal));

       endsr;


       // Read the first page of the subfile for the current
       // screen.
       begsr ReadFirstPage;

         exsr CalcScrSizes;

         *in10 = DspWide;
         *in21 = *off;
         *in22 = *off;
         *in23 = *on;

         write DFHEADER;

         // Position file pointer / query.
         select;
         // when Screen = ?;
         other;
           // Screen 1 is default.
           EOD1 = *off;
           SflEmpty1 = *on;
           SFLR1#T = 0;
           write DFSFC1;
           exsr SF1_QUERY;
         endsl;

         if     not Err.e
            and not EOD1;
           exsr ReadNextPage;
         endif;

         if DspMsg = '';
           DspMsg = RtvAMsgAB(1006);
         endif;

       endsr;


       // Read the next page of the subfile for the current screen.
       begsr ReadNextPage;

         for SflRec = 1 to PgLen;

           // Fetch next row.
           select;
           // when Screen = 1;
           other;
             // Screen 1 is default.
             exsr SF1_FETCH;
             if Err.e;
               EOD1 = *on;
             elseif EOD1;
               DspMsg = RtvAMsgAB(1017);
               leave;
             endif;
           endsl;

           // Write next subfile record.
           select;
           // when Screen = 1;
           other;
             // Screen 1 is default.
             if SFLR1#T >= 9999;
               DspMsg = RtvAMsgAB(1901);
               leave;
             endif;
             exsr SetDFSFR1;
             SFLR1# = SFLR1#T + 1;
             write DFSFR1;
             SFLR1#T = SFLR1#;
             SflEmpty1 = *off;
             if SflRec = 1;
               D__CURREC = SFLR1#T;
             endif;
             if %rem(SFLR1#T:PgLen) = 0;
               leave;
             endif;
           endsl;

         endfor;

         // Retain cursor location if it is within the subfile page.
         select;
         // when Screen = 1;
         other;
           // Screen 1 is default.
           if     CursRow >= PgTopl
              and (       %rem(SFLR1#T:PgLen) = 0
                      and CursRow < PgTopl + PgLen
                   or CursRow < PgTopl + %rem(SFLR1#T:PgLen));
             SetCurs = *on;
           endif;
         endsl;

       endsr;


       // Set field values and indicators for subfile record DFSFR1.
       // All necessary data should be available when executing
       // this subroutine.
       begsr SetDFSFR1;

         clear *all DFSFR1;
         exsr ClrIndDFSFR1;
         exsr SetFldDFSFR1;
         exsr SetDerivedFldDFSFR1;
         exsr SetIndDFSFR1;

       endsr;


       // Clear ALL indicators for subfile record DFSFR1.
       begsr ClrIndDFSFR1;

         *in31 = *off; // error on D_YEARA if *on
         *in32 = *off; // error on D_MONTHA if *on
         *in33 = *off; // error on D_DAYA if *on
         *in34 = *off; // error on D_WEEKA if *on
         *in35 = *off; // error on D_DNUMA if *on
         *in36 = *off; // error on D_TYPE if *on
         *in61 = *off; // error on option field if *on
         *in72 = *off; // subfile fields are editable if *on
         *in74 = *off; // subfile key fields are editable if *on
         *in81 = *off; // mark as "deleted" if *on
         *in82 = *off; // mark as "stale" if *on
         *in88 = *off; // disable option field if *on
         *in89 = *off; // disable subfile record if *on

       endsr;


       // Set field values for subfile record DFSFR1.
       // All necessary data should be available when executing
       // this subroutine.
       begsr SetFldDFSFR1;

         // Subfile record statusfield:
         //   N = subfile record represents a new data record.
         //   D = data record has been deleted.
         //   S = subfile record may contain stale data (data rec. updated).
         //   * = option field is disabled.
         //   X = subfile record is disabled.
         D__STAT = '';

         // Set hidden primary key fields.
         D__PK1 = NWDYEAR;
         D__PK2 = NWDMONTH;
         D__PK3 = NWDDAY;
         D__PK4 = NWDWEEK;
         D__PK5 = NWDDNUM;

         D_YEAR  = NWDYEAR;
         D_MONTH = NWDMONTH;
         D_DAY   = NWDDAY;
         D_WEEK  = NWDWEEK;
         D_DNUM  = NWDDNUM;
         D_TYPE  = NWDTYPE;

       endsr;


       // Set derived field values for subfile record DFSFR1, which are
       // dependent only on fields in the same subfile record.
       begsr SetDerivedFldDFSFR1;

         D__TYPE = D_TYPE;

         if D_YEAR > 0;
           evalr D_YEARA  = %char(D_YEAR);
         else;
           D_YEARA = '';
         endif;
         if D_MONTH > 0;
           evalr D_MONTHA  = %char(D_MONTH);
         endif;
         if D_DAY > 0;
           evalr D_DAYA  = %char(D_DAY);
         else;
           D_DAYA = '';
         endif;
         if D_WEEK > 0;
           evalr D_WEEKA  = %char(D_WEEK);
         else;
           D_WEEKA = '';
         endif;
         if D_DNUM > 0;
           evalr D_DNUMA  = %char(D_DNUM);
         else;
           D_DNUMA = '';
         endif;

         D_TNAME = GetNwdtName(D_TYPE);
         if D_TNAME = '';
           D_TNAME = '?';
         endif;

         t = '';
         dt = *loval;
         wk = 0;
         dn = 0;
         if D_YEAR > 0;
           if     D_MONTH > 0
              and D_DAY > 0;
             dt = MakeGdt(D_YEAR:D_MONTH:D_DAY);
           elseif     D_WEEK > 0
                  and D_DNUM > 0;
             dt = Wdt2Gdt(MakeWdt(D_YEAR:D_WEEK:D_DNUM));
           endif;
         endif;
         if dt <> *loval;
           x = %rem(Gdt2Wdt(dt):1000);
           wk = %div(x:10);
           dn = %rem(x:10);
         endif;
         if D_DNUM > 0;
           t = ConcatText(t:IsoWkdayName(D_DNUM:'*SHORTC'):' ');
         elseif dn > 0;
           t = ConcatText(t:IsoWkdayName(dn:'*SHORTC'):' ');
         endif;
         if D_WEEK > 0;
           t = ConcatText(t:'W' + FmtInt(D_WEEK:'00'):' ');
         elseif wk > 0;
           t = ConcatText(t:'W' + FmtInt(wk:'00'):' ');
         endif;
         if D_MONTH > 0;
           t = ConcatText(t:MonthName(D_MONTH:'*SHORTC'):' ');
         elseif dt <> *loval;
           t = ConcatText(t:MonthName(%subdt(dt:*m):'*SHORTC'):' ');
         endif;
         if D_DAY > 0;
           t = ConcatText(t:OrdinalNumText(D_DAY):' ');
         elseif dt <> *loval;
           t = ConcatText(t:OrdinalNumText(%subdt(dt:*d)):' ');
         endif;
         D_DAYINFO = t;

       endsr;


       // Set indicators for subfile record DFSFR1.
       // This subroutine expects that all indicators are cleared with
       // subr. "SetIndDFSFR1" and that all fields are filled (not
       // necessarily with subr. "SetFldDFSFR1").
       begsr SetIndDFSFR1;

         *in72 =     ModeEdit and not SbNoInlUpd
                 and D__STAT <> 'D' and D__STAT <> 'X';
         *in74 = *in72 and D__STAT = 'N';
         *in81 = D__STAT = 'D';
         *in82 = D__STAT = 'S';
         *in88 = D__STAT = '*' or D__STAT = 'N' or D__STAT = 'D';
         *in89 = D__STAT = 'X';

       endsr;


       // Validate the subfile for the current screen.
       // Set indicator "SflPcs" to *on if the subfile needs to be processed
       // by executing subr. "PcsSubfile", e.g. if one or more options have
       // been entered.
       // Set subfile field "D__PCS" to one of the following values for each
       // record that should be processed in subr. "PcsSubfile":
       //   "F" : request processing of subfile fields only;
       //   "O" : request processing of subfile option only;
       //   "P" : request processing of subfile fields and option.
       // Set ds "Err" if the subfile has errors (e.g. an invalid option),
       // in which case "PcsSubfile" is not executed.
       begsr ValSubfile;

         SflPcs = *off;

         if     Screen = 1
            and SflEmpty1;
           leavesr;
         endif;

         del# = 0;  // # to delete

         sflopt = '';  // last valid option

         for SflRec = 1 to SFLR1#T;

           select;
           // when Screen = 1;
           other;
             // Screen 1 is default.
             chain SflRec DFSFR1;
             if     D__STAT <> 'D'
                and D__STAT <> 'X';

               // Validate subfile record.

               exsr ClrIndDFSFR1;

               dou 0=0;

               if     ModeEdit
                  and (   not SbNoInlUpd
                       or D__STAT = 'N');

                 // Interprete numeric subfield values.

                 dou 0=0;

                 if IrNumber(D_YEARA:numValue:%len(NWDYEAR):0:'+');
                   D_YEAR = numValue;
                 else;
                   L_SetErr(RtvAMsgAB(1036:CAmsFatal):'NWDYEAR');
                   leave;
                 endif;
                 if IrNumber(D_MONTHA:numValue:%len(NWDMONTH):0:'+');
                   D_MONTH = numValue;
                 else;
                   L_SetErr(RtvAMsgAB(1036:CAmsFatal):'NWDMONTH');
                   leave;
                 endif;
                 if IrNumber(D_DAYA:numValue:%len(NWDDAY):0:'+');
                   D_DAY = numValue;
                 else;
                   L_SetErr(RtvAMsgAB(1036:CAmsFatal):'NWDDAY');
                   leave;
                 endif;
                 if IrNumber(D_WEEKA:numValue:%len(NWDWEEK):0:'+');
                   D_WEEK = numValue;
                 else;
                   L_SetErr(RtvAMsgAB(1036:CAmsFatal):'NWDWEEK');
                   leave;
                 endif;
                 if IrNumber(D_DNUMA:numValue:%len(NWDDNUM):0:'+');
                   D_DNUM = numValue;
                 else;
                   L_SetErr(RtvAMsgAB(1036:CAmsFatal):'NWDDNUM');
                   leave;
                 endif;

                 enddo;

                 if Err.e;
                   // Set error indicators (31-69); see "FEMap".
                   exsr SetErrFldsInd;
                   leave;
                 endif;

               endif;

               if     ModeEdit
                  and        D__STAT = 'N'
                         and (   D_YEARA <> ''
                              or D_MONTHA <> ''
                              or D_DAYA <> ''
                              or D_WEEKA <> ''
                              or D_DNUMA <> ''
                              or D_TYPE <> '')
                      or     not SbNoInlUpd
                         and D__STAT <> 'N'
                         and D_TYPE <> D__TYPE;

                 D__PCS = 'F'; // process fields

                 // Validate subfile fields.

                 dou 0=0;

                 if D_TYPE = '';
                   L_SetErr(RtvAMsgAB(5001:CAmsFatal):'NWDTYPE');
                   leave;
                 endif;

                 if GetNwdtName(D_TYPE) = '';
                   L_SetErr(RtvAMsgAB(7003:CAmsFatal:D_TYPE):'NWDTYPE');
                 endif;

                 if D__STAT = 'N';

                   if     D_YEAR > 0
                      and D_YEAR < 100;
                     D_YEAR = YY2YYYY(D_YEAR);
                   endif;

                   if D_MONTH > 12;
                     L_SetErr(RtvAMsgAB(5000:CAmsFatal):'NWDMONTH');
                     leave;
                   endif;
                   if    D_DAY > 31
                      or     D_MONTH = 2
                         and D_DAY > 29;
                     L_SetErr(RtvAMsgAB(5000:CAmsFatal):'NWDDAY');
                     leave;
                   endif;
                   if D_DNUM > 7;
                     L_SetErr(RtvAMsgAB(5000:CAmsFatal):'NWDDNUM');
                     leave;
                   endif;
                   If     D_DAY = 0
                      and D_MONTH > 0;
                     L_SetErr(RtvAMsgAB(5011:CAmsFatal):'NWDDAY');
                     leave;
                   endif;
                   If     D_DNUM = 0
                      and D_WEEK > 0;
                     L_SetErr(RtvAMsgAB(5011:CAmsFatal):'NWDDNUM');
                     leave;
                   endif;
                   if     D_DAY = 0
                      and D_DNUM = 0;
                     L_SetErr(RtvAMsgAB(7001:CAmsFatal):'NWDDAY':'NWDDNUM');
                     leave;
                   endif;
                   if     D_DAY > 0
                      and D_DNUM > 0;
                     L_SetErr(RtvAMsgAB(7002:CAmsFatal):'NWDDAY':'NWDDNUM');
                     leave;
                   endif;

                   if D_YEAR > 0;
                     if     D_MONTH > 0
                        and D_DAY > 0;
                       if not IsValidGdt(D_YEAR:D_MONTH:D_DAY);
                         L_SetErr(RtvAMsgAB(5000:CAmsFatal)
                                 :'NWDYEAR':'NWDMONTH':'NWDDAY');
                         leave;
                       endif;
                     endif;
                     if     D_WEEK > 0
                        and D_DNUM > 0;
                       if Wdt2Gdt(MakeWdt(D_YEAR:D_WEEK:D_DNUM)) = *loval;
                         SetErr(RtvAMsgAB(5000:CAmsFatal)
                               :'NWDYEAR':'NWDWEEK':'NWDDNUM');
                         leave;
                       endif;
                     endif;
                   endif;

                 endif;

                 enddo;

                 if Err.e;
                   // Set error indicators (31-69); see "FEMap".
                   exsr SetErrFldsInd;
                   leave;
                 endif;

               endif;

               if     D__STAT <> 'N'
                  and D__STAT <> '*'
                  and D_SFLOPT <> '';

                 if D__PCS = 'F';
                   D__PCS = 'P'; // process fields & option
                 else;
                   D__PCS = 'O'; // process option
                 endif;

                 // Validate option.

                 evalr D_SFLOPT = %trim(D_SFLOPT);

                 dou 0=0;

                 if        D_SFLOPT <> ' 1'
                       and D_SFLOPT <> ' 3'
                       and D_SFLOPT <> ' 4'
                    or     D_SFLOPT = ' 1'
                       and not ModeSelect
                    or     D_SFLOPT = ' 3'
                       and (not ModeEdit or SbNoAdd)
                    or     D_SFLOPT = ' 4'
                       and (not ModeEdit or SbNoDel);
                   L_SetErr(RtvAMsgAB(1003:CAmsFatal));
                   leave;
                 endif;

                 if D_SFLOPT = ' 1';
                   if sflopt = D_SFLOPT;
                     L_SetErr(RtvAMsgAB(1042:CAmsFatal));
                     leave;
                   elseif sflopt <> '';
                     L_SetErr(RtvAMsgAB(1043:CAmsFatal));
                     leave;
                   endif;
                 elseif sflopt = ' 1';
                   L_SetErr(RtvAMsgAB(1043:CAmsFatal));
                   leave;
                 endif;

                 if     sflopt <> ''
                    and D_SFLOPT <> sflopt
                    and (   sflopt = ' 3'
                         or D_SFLOPT = ' 3');
                   L_SetErr(RtvAMsgAB(1045:CAmsFatal));
                   leave;
                 endif;

                 if     sflopt <> ''
                    and D_SFLOPT <> sflopt
                    and (   sflopt = ' 4'
                         or D_SFLOPT = ' 4');
                   L_SetErr(RtvAMsgAB(1044:CAmsFatal));
                   leave;
                 endif;

                 sflopt = D_SFLOPT;

                 if D_SFLOPT = ' 4';
                   del# = del# + 1;
                 endif;

                 enddo;

                 if Err.e;
                   *in61 = *on;
                   leave;
                 endif;

               endif;

               enddo;

               if    D__PCS = 'F'
                  or D__PCS = 'O'
                  or D__PCS = 'P';
                 SflPcs = *on;
               endif;

               exsr SetIndDFSFR1;
               update DFSFR1;

             endif;

           endsl;

           // Exit if first error encountered.
           if Err.e;
             D__CURREC = Sflrec;
             leave;
           endif;

         endfor;

         if     not Err.e
            and SflPcs
            and del# > 0;
           if not PresentConfWdw(
                      'Delete ' + %char(del#) + ' ' +
                      PluralNoun('Record':del#) + ' ?');
             L_SetErr(RtvAMsgAB(1291:CAmsFatal));
           endif;
         endif;

       endsr;


       // Process all subfile records where "D__PCS" is "F", "O" or "P"
       // for the current screen.
       // Set "D__PCS" to "C" (completed) for each subfile record which
       // has been successfully processed.
       // Set ds "Err" in case of an error.
       begsr PcsSubfile;

         if     Screen = 1
            and SflEmpty1;
           leavesr;
         endif;

         add# = 0; // # added
         upd# = 0; // # updated
         del# = 0; // # deleted
         cpy# = 0; // # copied

         exit   = *off;
         cancel = *off;

         newcurrec = 0;

         sflrecs = SFLR1#T;

         for SflRec = 1 to sflrecs;

           DspMsg = '';

           select;
           // when Screen = 1;
           other;
             // Screen 1 is default.
             chain SflRec DFSFR1;
             if    D__PCS = 'F'
                or D__PCS = 'O'
                or D__PCS = 'P';

               // Process subfile record.

               exsr ClrIndDFSFR1;

               clear DrKey;
               DrKey.f1 = D__PK1;
               DrKey.f2 = D__PK2;
               DrKey.f3 = D__PK3;
               DrKey.f4 = D__PK4;
               DrKey.f5 = D__PK5;

               dou 0=0;

               if    D__PCS = 'F'
                  or D__PCS = 'P';

                 // Process subfile fields.

                 dou 0=0;

                 if D__STAT = 'N';

                   // ADD

                   if    D_DAY > 0
                      or D_DNUM > 0;

                     clear *all NWDREC;
                     NWDYEAR  = D_YEAR;
                     NWDMONTH = D_MONTH;
                     NWDDAY   = D_DAY;
                     NWDWEEK  = D_WEEK;
                     NWDDNUM  = D_DNUM;
                     chain(n) (NWDYEAR:NWDMONTH:NWDDAY:NWDWEEK:NWDDNUM)
                              CSYSBASEF2;
                     if %found;
                       L_SetErr(RtvAMsgAB(1024:CAmsFatal)
                               :'NWDYEAR':'NWDMONTH':'NWDDAY'
                               :'NWDWEEK':'NWDDNUM');
                       leave;
                     endif;
                     NWDTYPE = D_TYPE;
                     write(e) NWDREC;
                     if %error;
                       L_SetErr(RtvAMsgAB(9106:CAmsFatal
                                    : %char(NWDYEAR) +'/' +%char(NWDMONTH) +'/'
                                     +%char(NWDDAY)  +'/' +%char(NWDWEEK)  +'/'
                                     +%char(NWDDNUM)
                                    :%trim(PSI.filename))
                               :'NWDYEAR':'NWDMONTH':'NWDDAY'
                               :'NWDWEEK':'NWDDNUM');
                       leave;
                     endif;
                     D__PK1 = NWDYEAR;
                     D__PK2 = NWDMONTH;
                     D__PK3 = NWDDAY;
                     D__PK4 = NWDWEEK;
                     D__PK5 = NWDDNUM;
                     add# = add# + 1;
                     D_AUIND = 'A';
                   endif;

                 else;

                   // UPDATE

                   NWDYEAR  = DrKey.f1;
                   NWDMONTH = DrKey.f2;
                   NWDDAY   = DrKey.f3;
                   NWDWEEK  = DrKey.f4;
                   NWDDNUM  = DrKey.f5;
                   chain (NWDYEAR:NWDMONTH:NWDDAY:NWDWEEK:NWDDNUM)
                         CSYSBASEF2;
                   if not %found;
                     L_SetErr(RtvAMsgAB(1013:CAmsFatal)
                             :'NWDTYPE');
                     leave;
                   endif;
                   NWDTYPE = D_TYPE;
                   update(e) NWDREC;
                   if %error;
                     L_SetErr(RtvAMsgAB(9106:CAmsFatal
                                  : %char(NWDYEAR) +'/' +%char(NWDMONTH) +'/'
                                   +%char(NWDDAY)  +'/' +%char(NWDWEEK)  +'/'
                                   +%char(NWDDNUM)
                                  :%trim(PSI.filename))
                             :'NWDTYPE');
                     leave;
                   endif;
                   upd# = upd# + 1;
                   D_AUIND = 'U';

                 endif;

                 enddo;

                 if Err.e;
                   // Set error indicators (31-69); see "FEMap".
                   exsr SetErrFldsInd;
                   leave;
                 elseif D__STAT = 'N';
                   D__STAT = ''; // clear "new" status
                 endif;

               endif;

               if    D__PCS = 'O'
                  or D__PCS = 'P';

                 // Process option.

                 dou 0=0;

                 evalr D_SFLOPT = %trim(D_SFLOPT);

                 NWDYEAR  = DrKey.f1;
                 NWDMONTH = DrKey.f2;
                 NWDDAY   = DrKey.f3;
                 NWDWEEK  = DrKey.f4;
                 NWDDNUM  = DrKey.f5;

                 if    D_SFLOPT = ' 1'
                    or D_SFLOPT = ' 4';
                   if D_SFLOPT = ' 4';
                     chain (NWDYEAR:NWDMONTH:NWDDAY:NWDWEEK:NWDDNUM)
                           CSYSBASEF2;
                   else;
                     chain(n) (NWDYEAR:NWDMONTH:NWDDAY:NWDWEEK:NWDDNUM)
                              CSYSBASEF2;
                   endif;
                   if not %found;
                     L_SetErr(RtvAMsgAB(1013:CAmsFatal));
                     leave;
                   endif;
                 endif;

                 if D_SFLOPT = ' 1';
                   exit = *on;
                   // Set output parms to selected key.
                   Rtncd = 10;
                 endif;

                 if D_SFLOPT = ' 3';
                   exsr SetIndDFSFR1;
                   update DFSFR1;
                   sfD_YEARA  = D_YEARA;
                   sfD_MONTHA = D_MONTHA;
                   sfD_DAYA   = D_DAYA;
                   sfD_WEEKA  = D_WEEKA;
                   sfD_DNUMA  = D_DNUMA;
                   sfD_TYPE   = D_TYPE;
                   sfD_TNAME  = D_TNAME;
                   exsr AddNewRecord;
                   chain SFLR1#T DFSFR1;
                   exsr ClrIndDFSFR1;
                   D_YEARA  = sfD_YEARA;
                   D_MONTHA = sfD_MONTHA;
                   D_DAYA   = sfD_DAYA;
                   D_WEEKA  = sfD_WEEKA;
                   D_DNUMA  = sfD_DNUMA;
                   D_TYPE   = sfD_TYPE;
                   D_TNAME  = sfD_TNAME;
                   exsr SetIndDFSFR1;
                   update DFSFR1;
                   chain SflRec DFSFR1;
                   exsr ClrIndDFSFR1;
                   cpy# = cpy# + 1;
                   if newcurrec = 0;
                     newcurrec = SFLR1#T;
                   endif;
                 endif;

                 if D_SFLOPT = ' 4';
                   delete(e) NWDREC;
                   if %error;
                     L_SetErr(RtvAMsgAB(9104:CAmsFatal
                                  : %char(NWDYEAR) +'/' +%char(NWDMONTH) +'/'
                                   +%char(NWDDAY)  +'/' +%char(NWDWEEK)  +'/'
                                   +%char(NWDDNUM)
                                  :%trim(PSI.filename)));
                     leave;
                   endif;
                   // Set "deleted" status.
                   D__STAT = 'D';
                   del# = del# + 1;
                 endif;

                 enddo;

                 if Err.e;
                   *in61 = *on;
                   leave;
                 endif;

               endif;

               enddo;

               if not Err.e;
                 exsr SetDerivedFldDFSFR1;
                 D__PCS = 'C';
                 if not exit;
                   D_SFLOPT = '';
                 endif;
               endif;

               exsr SetIndDFSFR1;
               update DFSFR1;

             endif;

           endsl;

           // Exit if first error encountered, if exited or if cancelled.
           if    Err.e
              or exit
              or cancel;
             D__CURREC = Sflrec;
             newcurrec = 0;
             leave;
           endif;

         endfor;

         if newcurrec > 0;
           D__CURREC = newcurrec;
         endif;

         // Add informational messages.
         if    add# <> 0
            or upd# <> 0
            or del# <> 0
            or cpy# <> 0;
           if    add# <> 0
              or upd# <> 0
              or del# <> 0;
             AddToDspMsgList(RtvAMsgAB(1280:CAmsInfo
                 :%char(add#):%char(upd#):%char(del#)));
           endif;
           if cpy# <> 0;
             AddToDspMsgList(RtvAMsgAB(1281:CAmsInfo
                 :%char(cpy#)));
           endif;
         endif;

         if exit;
           // Exit program.
           Screen = 0;
         endif;

       endsr;


       // Add new data record.
       begsr AddNewRecord;

         if SFLR1#T >= 9999;
           DspMsg = RtvAMsgAB(1901);
           leavesr;
         endif;

         // Add "new" subfile record (D__STAT = 'N').
         select;
         // when Screen = 1;
         other;
           // Screen 1 is default.
           if SflEmpty1;
             *in10 = DspWide;
             *in21 = *off;
             *in22 = *off;
             *in23 = *on;
             write DFSFC1;
             SFLR1# = 1;
           else;
             SFLR1# = SFLR1#T + 1;
           endif;
           clear *all DFSFR1;
           exsr ClrIndDFSFR1;
           D__STAT = 'N';
           exsr SetIndDFSFR1;
           write DFSFR1;
           SFLR1#T = SFLR1#;
           D__CURREC = SFLR1#T;
           SflEmpty1 = *off;
         endsl;

       endsr;


       // Check if a new positioning key has been entered.
       // Set "NewPoskey" accordingly.
       // Set ds "Err" if an invalid positioning has been entered.
       begsr CheckPositioning;

         select;
         // when Screen = ?;
         other;
           // Screen 1 is default.
           select;
           when D__POS1F1A <> Poskey1.f1a;
             NewPoskey = 1;
             if not IrNumber(D__POS1F1A:numValue:%len(D__POS1F1A):0:'+');
               L_SetErr(RtvAMsgAB(1051:CAmsFatal));
               leavesr;
             endif;
             D__POS1F1 = numValue;
             if D__POS1F1 > 0;
               evalr D__POS1F1A = %char(D__POS1F1);
             else;
               D__POS1F1A = '';
             endif;
           endsl;
         endsl;

       endsr;


       // Set the correct "Poskey*" data structure according to "NewPoskey".
       begsr SetPoskey;

         CurPoskey = NewPoskey;

         select;
         when CurPoskey = 1;
           clear Poskey1;
           Poskey1.f1  = D__POS1F1;
           Poskey1.f1a = D__POS1F1A;
         endsl;

       endsr;


       // Set the current screen positioning fields.
       begsr SetPosFields;

         select;
         // when Screen = ?;
         other;
           // Screen 1 is default.
           D__POS1F1  = Poskey1.f1;
           D__POS1F1A = Poskey1.f1a;
         endsl;

       endsr;


      /include QINCSRC,DPGM_SUBR


      /end-free
     p                 e


      /include QINCSRC,DPGM_LPI


** FEMap (nnnnnnnnnnnnii, field/attribute name where ?=any, indicator)
NWDYEAR     31
NWDMONTH    32
NWDDAY      33
NWDWEEK     34
NWDDNUM     35
NWDTYPE     36
** CursLocs (snrrccc, screensize/screen#/row/col, s=W/N/blank, n=blank=all)
 107007
N 22001
W 25001
** Text
Non-Work Days
Edit
Display
Select
** FunText
F1=Help
F2=
F3=
F4=
F5=
F6=Add
F7=
F8=
F9=
F10=
F11=
F12=
F13=
F14=
F15=
F16=
F17=
F18=
F19=
F20=
F21=
F22=
F23=
F24=
** SfoText
1=Select
2=
3=Copy
4=Delete
5=
6=
7=
8=
9=
10=
11=
12=
13=
14=
15=
16=
17=
18=
19=

